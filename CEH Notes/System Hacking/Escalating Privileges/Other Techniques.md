# Other Techniques

▪ Access Token Manipulation In Windows OSs, access tokens are used to determine the security context of a process or thread. These tokens include the access profile (identity and privileges) of a user associated with a process. After a user is authenticated, the system produces an access token. Every process the user executes makes use of this access token. The system verifies this access token when a process is accessing a secured object.
Any Windows user can modify these access tokens so that the process appears to belong to some other user than the one who started it. Then, the process acquires the security context of the new token. For example, Windows administrators have to log on as normal users and need to run their tools with admin privileges using token manipulation command “runas.” Attackers can exploit this to access the tokens of other users, or generate spoofed tokens, to escalate privileges and perform malicious activities while evading detection.

▪ Parent PID Spoofing
Attackers attempt to bypass the internal process or service that tracks security measures and to escalate privileges by spoofing the parent process ID (PPID) of a recently added process. These new processes are derived directly from their parent if they are not specified precisely. An explicit specification can be made by providing a PPID for the new process via the CreateProcess API. Usually, this API call process consists of specific arguments to determine the particular PPID to be used. The appropriate PPID can be set to the process that is derived from the system through system processes such as svchost.exe or consent.exe using Windows User Account Control (UAC). Attackers abuse these methods to bypass security mechanisms that restrict process spawning from a parent, tools that analyze parent–child relationships, and maintain persistence to elevate their privileges.

▪ Application Shimming The Windows OSs use a Windows Application Compatibility Framework called shims to provide compatibility between the older and newer versions of Windows. For example, application shimming allows programs created for Windows XP to be compatible with Windows 11. Shims provide a buffer between the program and the OS. This buffer is referenced when a program is executed to verify whether the program requires access to the shim database. When a program needs to communicate with the OS, the shim database uses API hooking to redirect the code. All the shims installed by the default Windows installer (sbinst.exe) are stored at %WINDIR%\AppPatch\sysmain.sdb hklm\software\microsoft\windows nt\currentversion\appcompatflags\installedsdb Shims run in user mode, and they cannot modify the kernel. Some of these shims can be used to bypass UAC (RedirectEXE), inject malicious DLLs (InjectDLL), capture memory addresses (GetProcAddress), etc. An attacker can use these shims to perform different attacks including disabling Windows Defender, privilege escalation, installing backdoors, etc.

▪ Filesystem Permission Weakness
Many processes in the Windows OSs execute binaries automatically as part of their functionality or to perform certain actions. If the filesystem permissions of these binaries are not set properly, then the target binary file may be replaced with a malicious file, and the actual process can execute it. If the process that is executing this binary has higher-level permissions, then the binary also executes under higher-level permissions, which may include SYSTEM. Attackers can exploit this technique to replace original binaries with malicious binaries to escalate privileges. Attackers use this technique to manipulate Windows service binaries and self-extracting installers.

▪ Path Interception
Path interception is a method of placing an executable in a particular path in such a way that the application will execute it in place of the legitimate target. Attackers can exploit several flaws or misconfigurations to perform path interception like unquoted paths (service paths and shortcut paths), path environment variable misconfiguration, and search order hijacking. Path interception helps an attacker to maintain persistence on a system and escalate privileges.

▪ Abusing Accessibility Features
Attackers create persistence and escalate privileges by embedding and running malicious code within Windows accessibility features. Accessibility features are activated using key combinations even before a user logs into a system. An attacker can manipulate these features to obtain backdoor access without logging into the system. In a Windows environment, these programs are stored at the location C:\Windows\System32\ and can be launched by pressing specific keys during a system reboot. Attackers gain escalated privileges by replacing one of the accessibility features with cmd.exe or by replacing binaries in the registry to gain backdoor access when a key combination is pressed at the login screen. This technique allows attackers to obtain system-level access. The following are other accessibility features abused by attackers:

 o On-screen keyboard: C:\Windows\System32\osk.exe 

o Magnifier: C:\Windows\System32\Magnify.exe o Narrator: C:\Windows\System32\Narrator.exe o Display switcher: C:\Windows\System32\DisplaySwitch.exe 

o App switcher: C:\Windows\System32\AtBroker.exe o Sticky keys: C:\Windows\System32\sethc.exe

▪ SID-History Injection
In Windows, Windows Security Identifier (SID) is a unique value assigned to each user and group accounts issued by the domain controller (DC) at the time of creation. These AD accounts can store multiple SID values in the SID-history attribute, which are used when migrating the user from one domain to another. Attackers abuse this feature to inject the SID value of an administrator or equivalent account containing higher privileges into the compromised user account’s SID-history attribute. This injection could elevate the user account privileges, using which the attacker can access restricted resources or remote systems. Attackers can also access other domain resources by performing further movement techniques such as remote services, SMB/Windows admin shares, or Windows remote management.

▪ COM Hijacking
The Component Object Model (COM) is an interface module in Windows environments that enables a software component to interact with another software component’s code without being aware of their actual implementation. Attackers exploit COM objects by hijacking their valid references and adding their own references to infect the target system and achieve persistence. This process involves tampering or replacing object references with malicious content in Windows Registry. When a user executes that commonly used object, the malicious code is automatically executed, allowing attackers maintain persistence and escalate the privileges given to the object. Attackers might use the following techniques while performing COM hijacking: 

o By taking advantage of the registry loading process and creating a malicious user object under the HKEY_CURRENT_USER\Software\Classes\CLSID\ registry, which is loaded by the system
before loading the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\ registry
o By interchanging existing DLLs or executable names with malicious payloads that will be executed when legitimate DLLs or executables are executed
o By taking advantage of orphan requests made by the system components that are not yet defined in the registry, creating malicious COM objects for those requests in the HKEY_CURRENT_USER registry and mapping them to the malicious payloads hidden in the file system

▪ Scheduled Tasks in Windows
Scheduled tasks allow users to perform routine tasks chosen for a computer automatically. Windows includes utilities such as at and schtasks. A user with administrator privileges can use these utilities in conjunction with Task Scheduler to schedule programs or scripts that can be executed at a particular date and time. If a user provides proper authentication, they can also schedule a task from a remote system using a Remote Procedure Call (RPC). An attacker can use this technique to execute malicious programs at system startup, maintain persistence, perform remote execution, escalate privileges, etc.

▪ Scheduled Tasks in Linux 
Linux utilizes cron or a crond, an instruction-based utility, for automating task scheduling. Attackers abuse this utility for triggering a malicious payload when a specific task is scheduled to be executed. This scheduler assists users with administrator privileges in configuring cron and executing a monotonous cron job at a specific time. cron executes all the commands from the crontab file located at its root, /etc/crontab. Attackers escalate system privileges by making changes to the scripts executed by cron located at /etc/crontab. By modifying these scripts, attackers can force malicious scripts to be executed automatically during system reboot for gaining root privileges.

![image.png](Other%20Techniques/image.png)

▪ Launch Daemon
During the macOS booting process, launchd is executed to complete the system initialization process. Parameters for each launch-on-demand system-level daemon found in /System/Library/LaunchDaemons and /Library/LaunchDaemons are loaded using launchd. These daemons have property list files (plist) that are linked to executables that run at the time of booting. Attackers can create and install a new launch daemon, which can be configured to execute at boot-up time using launchd or launchctl to load plist into the relevant directories. The weak configurations allow an attacker to alter the existing launch daemon’s executable to maintain persistence or to escalate privileges.

▪ Plist Modification
In macOS, plist (property list) files include all the necessary information that is needed to configure applications and services. These files describe when programs should execute, the executable file path, program parameters, essential OS permissions, etc. The plist files are stored at specific locations like /Library/Preferences (which execute with high-level privileges) and ~/Library/Preferences (which execute with user privileges). Attackers can access and alter these plist files to execute malicious code on behalf of a legitimate user, and further use them as a persistence mechanism and to escalate privileges.

▪ Setuid and Setgid
In Linux and macOS, if an application uses setuid or setgid, the application will execute with the privileges of the owning user or group, respectively. Generally, the applications run under the current user’s privileges. There are certain circumstances where the programs must be executed with elevated privileges but the user running the program does not need the elevated privileges. In this scenario, one can set the setuid or setgid flags for their applications. An attacker can exploit the applications with the setuid or setgid flags to execute malicious code with elevated privileges.

▪ Web Shell
A web shell is a web-based script that allows access to a web server. Web shells can be created in all OSs like Windows, Linux, and macOS. Attackers create web shells to inject a malicious script on a web server to maintain persistent access and escalate privileges. Attackers use a web shell as a backdoor to gain access and control a remote server. Generally, a web shell runs under the current user’s privileges. Using a web shell, an attacker can perform privilege escalation by exploiting local system vulnerabilities. After escalating privileges, an attacker can install malicious software, change user permissions, add or remove users, steal credentials, read emails, etc.

▪ Abusing Sudo Rights
Sudo (substitute user do) is a UNIX-and Linux-based system utility that permits users to run commands as a superuser or root by using the security privileges of another user. An /etc/sudoers file includes the configuration of sudo rights. This file contains detailed information regarding access permissions, including commands that are allowed to run with or without passwords per user or group. 

Attackers can abuse sudo to escalate their privileges to run programs that the normal users are not allowed to run. For example, if an attacker has sudo-rights to run a cp command then he/she can overwrite an /etc/sudoers or /etc/shadow file with his/her own malicious file. By overwriting the content of the sudoers file, he/she can edit the permissions to run various restricted commands or programs to launch further attacks on the system.

▪ Abusing SUID and SGID Permissions Set User Identification (SUID) and Set Group Identification (SGID) are access permissions given to a program file in UNIX-based systems. These permissions usually allow the users on the system to run a program with temporarily elevated privileges or root privileges to execute a particular task. The files with SUID and SGID rights run with higher privileges. In Linux, there are some commands and binaries that can be executed by the attackers to elevate their privileges from non-root users to root users, if flags of SUID and SGID rights are set. Some of the executable commands that can be used by attackers to spawn a shell and escalate privileges are nmap, vim, less, more, bash, cat, cp, echo, find, nano, etc. Attackers can use the following commands to find SUID and SGID files in the target system: # Find SUID find / -perm -u=s -type f 2>/dev/null # Find GUID

find / -perm -g=s -type f 2>/dev/null 

▪ Kernel Exploits
Kernel exploits refer to programs that can exploit vulnerabilities present in the kernel to execute arbitrary commands or code with higher privileges. By successfully exploiting kernel vulnerabilities, attackers can attain superuser or root-level access to the target system. To run a kernel exploit, attackers must have configuration details of the target system. Attackers use the following commands to obtain details such as the OS, kernel version, and architecture of the target system: # OS cat /etc/issue # Kernel version uname -a # Architecture
cat /proc/version